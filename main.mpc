# -*- coding: utf-8 -*-
"""efc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JiFExoZxIjrf7ifxFSEF9yCq3ePzAvpk

Link colab: https://colab.research.google.com/drive/1JiFExoZxIjrf7ifxFSEF9yCq3ePzAvpk?usp=sharing
"""
import time
import sys
import math
import warnings

from sklearn.utils.multiclass import type_of_target
from sklearn.base import BaseEstimator, ClassifierMixin

from Compiler import mpc_math, ml

# -------------------------------- METRICS --------------------------------

def calculate_metrics(y_test, y_pred, positive_label=0, plain_test = True):
    true_positive_arr = Array(len(y_test), sint)
    false_positive_arr = Array(len(y_test), sint)
    false_negative_arr = Array(len(y_test), sint)

    if (plain_test): # Test is a normal python public array. Transform to secret shared to compare
        y_testing = y_test
        y_test = Array(len(y_testing), sint)
        y_test.assign(y_testing)
    @for_range(len(y_test))
    def f(i):
        y_t = y_test[i].reveal()
        y_p = y_pred[i].reveal()
        true_positive_arr[i] = ((y_p == positive_label) & (y_t == positive_label)).if_else(1,0)
        false_positive_arr[i] = ((y_p == positive_label) & (y_t != positive_label)).if_else(1,0)
        false_negative_arr[i] = ((y_p != positive_label) & (y_t == positive_label)).if_else(1,0)

    true_positive = sum(true_positive_arr)
    false_positive = sum(false_positive_arr)
    false_negative = sum(false_negative_arr)


    precision = (true_positive + false_positive != 0).if_else(true_positive / (true_positive + false_positive), 0)
    recall = (true_positive + false_negative != 0).if_else(true_positive / (true_positive + false_negative), 0)

    return precision, recall


# -------------------------------- UTILS --------------------------------

E = 2.71828

def find_indices_equal_to_value(arr, value):
    sum_of_equal_to_scalar = sum_of_equal_scalar(arr, value)
    sum_of_equal_public = sum_of_equal_to_scalar.reveal()

    results = arr.same_shape()

    for i in range(len(arr)):
        results[i] = (arr[i] == value).if_else(i, -1)

    results.sort()

    return results.get_part(sum_of_equal_public + 1, len(arr) - sum_of_equal_public-1)


def exponential_matrix(matrix):
    e = cfix(E)
    matrix_exponentiated = matrix.same_shape()
    for i in range(len(matrix)):
        for j in range(len(matrix)):
            matrix_exponentiated[i][j] = e**matrix[i][j] #TODO: VERY SLOW :(
            #matrix_exponentiated[i][j] = mpc_math.exp2_fx(matrix[i][j])
    return matrix_exponentiated

def log_1d(arr):
    log_1d_arr = arr.same_shape()
    for i in range(len(arr)):
        log_1d_arr[i] = mpc_math.log_fx(arr[i], E)
    return log_1d_arr

def log_2d(matrix):
    log_2d_matrix = matrix.same_shape()
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            log_2d_matrix[i][j] = mpc_math.log_fx(matrix[i][j], E)
    return log_2d_matrix

# Arrays creation

def zeros_1d_by_array(array):
    return array.same_shape().assign_all(0.0)

def zeros_1d(length):
    array = Array(length, sfix)
    return array.assign_all(0.0)

def zeros_1d_by_shape(length):
    array = Array(length, sfix)
    return array.assign_all(0.0)

def zeros_2d_by_matrix(matrix):
    return matrix.same_shape().assign_all(0.0)

def zeros_2d_by_shape(rows, columns):
    matrix = Matrix(rows, columns, sfix)
    return matrix.assign_all(0.0)

def zeros_3d_by_shape(a,b,c):
    matrix = MultiArray([a,b,c], sfix)
    return matrix.assign_all(0.0)

def zeros_4d_by_matrix(matrix):
    return matrix.same_shape().assign_all(0.0)

def zeros_4d_by_shape(a,b,c,d):
    matrix = MultiArray([a,b,c,d], sfix)
    return matrix.assign_all(0.0)

def zeros_4d(a,b,c,d):
    matrix = MultiArray([a,b,c,d], sfix)
    return matrix.assign_all(0.0)

# Array operations

def subtract_from_1d_array(arr, value):
    result = arr.same_shape()
    for i in range(len(arr)):
        result[i] = result[i] - value
    return result

def add_scalar_to_2d_matrix(matrix, scalar):
    result_matrix = matrix.same_shape()
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            result_matrix[i][j] = matrix[i][j]+scalar
    return result_matrix

def multiply_2d_matrix_by_scalar(matrix, scalar):
    result_matrix = matrix.same_shape()
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            result_matrix[i][j] = matrix[i][j]*scalar
    return result_matrix

def multiply_4d_matrix_by_scalar(matrix, scalar):
    result_matrix = matrix.same_shape()
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            for k in range(len(matrix[0][0])):
                for l in range(len(matrix[0][0][0])):
                    result_matrix[i][j][k][l] = matrix[i][j][k][l]*scalar
    return result_matrix

def divide_2d_matrix_by_scalar(matrix, scalar):
    result_matrix = matrix.same_shape()
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            result_matrix[i][j] = matrix[i][j]/scalar
    return result_matrix

def divide_4d_matrix_by_scalar(matrix, scalar):
    result_matrix = matrix.same_shape()
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            for k in range(len(matrix[0][0])):
                for l in range(len(matrix[0][0][0])):
                    result_matrix[i][j][k][l] = matrix[i][j][k][l]/scalar # TODO: Can we use list comprehensions?
    return result_matrix

def equal_scalar(array, scalar):
    is_equal = array.same_shape()
    for i in range(len(array)):
        is_equal[i] = (array[i]==scalar).if_else(1, 0)
    return is_equal

def sum_of_equal_scalar(arr, value):
    count = sint(0)
    for i in range(len(arr)):
        count = (arr[i] == value).if_else(count+1, count)
    return count

def negative_array(array):
    negative = array.same_shape()
    for i in range(len(array)):
        negative[i] = array[i] * -1
    return negative

def negative_matrix(matrix):
    negative = matrix.same_shape()
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            negative[i][j] = matrix[i][j] * -1 #TODO: 0-sfix or -1*sfix, what is faster? does it matter?
    return negative

def compute_max_from_array(arr): #TODO: do we need the extra array?
    length = arr.length
    max_value = sfix(-16383)
    for j in range(length):
        max_value = (max_value>arr[j]).if_else(max_value, arr[j])
    return max_value

def compute_max_from_matrix(matrix):
    max_value = sfix(-16383)
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            max_value = (max_value>matrix[i][j]).if_else(max_value, matrix[i][j])
    return max_value

def matrix_inverse(matrix, iterations, stop=True): #TOO: IS IT CORRECT??? I just took it from the official github. Also, VEEEEEEEEEEEEERY slow
    return ml.mr(matrix, iterations, stop=True) # SOURCE: https://github.com/data61/MP-SPDZ/blob/master/Compiler/ml.py#L3452

def cantor(x, y):
    output = Array(len(x), sfix)
    for i in range(len(x)):
        output[i] = (x[i] + y[i]) * (x[i] + y[i] + 1) / 2 + y[i]
    return output

def unique_list(arr, return_inverse = False, return_indices = False, duplicate_placeholder = -1):
    unique_values = arr.same_shape()
    found_duplicate = Array(len(arr), sint)
    if return_inverse:
        inverse_indices = Array(len(arr), sint)
    if return_indices:
        indices = Array(len(arr), sint)

    for i in range(len(arr)):
        for j in range(i):
            # Check if the current element is already in unique_values
            found_duplicate[i] = (arr[i] == arr[j]).if_else(1, found_duplicate[i]) #TODO: maybe break loop if found_duplicate is true

        # If not found, add it to unique_values. Else, set value as DUPLICATE_PLACEHOLDER
        unique_values[i] = (found_duplicate[i] == 1).if_else(duplicate_placeholder, arr[i])
        if return_indices:
            indices[i] = (found_duplicate[i] == 1).if_else(duplicate_placeholder, i)

    # Sort the results array, so that all "DUPLICATE_PLACEHOLDER" are at the front (assuming it is the smallest value)
    unique_values.sort()

    # Crop the "DUPLICATE_PLACEHOLDER"'s
    found_duplicate_sum = sum(found_duplicate).reveal() #TODO: REVEALING HERE - IS IT FINE?
    length_to_crop = len(unique_values) - found_duplicate_sum
    unique_values_cropped = unique_values.get_part(found_duplicate_sum, length_to_crop) #TODO: is it fine to reveal here? needs to be CINT....

    # get the inverse_indices
    if return_inverse:
        for i in range(len(arr)):
            @for_range(length_to_crop)
            def f(j):
                inverse_indices[i] = (unique_values_cropped[j] == arr[i]).if_else(j, inverse_indices[i])

    # get the indices
    if return_indices:
        indices.sort()
        indices_cropped = indices.get_part(found_duplicate_sum, length_to_crop)

    if return_indices and return_inverse:
        return unique_values_cropped, inverse_indices, indices_cropped

    if return_indices:
        return unique_values_cropped, indices_cropped

    if return_inverse:
        return unique_values_cropped, inverse_indices

    return unique_values_cropped

def smin(x, y):
    """
    Secure minimum between two sfix numbers.
    """
    return x * (x < y) + y * (y <= x)

def smax(x, y):
    """
    Secure maximum between two sfix numbers.
    """
    return x * (x > y) + y * (y >= x)

def min_along_axis(arr, axis):
    """
    Find the minimum value along a specified axis in a 2D array securely using MP-SPDZ.

    Parameters:
    - arr (list of lists of sfix): 2D array of secret shared values.
    - axis (int): Axis along which to find the minimum value (0 for rows, 1 for columns).

    Returns:
    - list of sfix or sfix: Minimum value(s) along the specified axis.
    """
    if axis == 0:
        # Find minimum values along rows (axis=0)
        min_values = sfix.Array(len(arr[0]))
        for j in range(len(arr[0])):  # Iterate over columns
            min_val = arr[0][j]
            for i in range(1, len(arr)):  # Iterate over rows
                min_val = smin(min_val, arr[i][j])
            min_values[j] = min_val
    elif axis == 1:
        # Find minimum values along columns (axis=1)
        min_values = []
        for row in arr:
            min_val = row[0]
            for val in row[1:]:
                min_val = smin(min_val, val)
            min_values.append(min_val)
    else:
        raise ValueError("Invalid axis. Use 0 for rows or 1 for columns.")

    return min_values

def max_along_axis(arr, axis=0):
    """
    Find the maximum value along a specified axis in a 2D array securely using MP-SPDZ.

    Parameters:
    - arr (list of lists of sfix): 2D array of secret shared values.
    - axis (int): Axis along which to find the maximum value (0 for rows, 1 for columns).

    Returns:
    - list of sfix: Maximum value(s) along the specified axis.
    """
    if axis == 0:
        # Transpose the array to work with columns as if they were rows
        transposed_arr = list(zip(*arr))
        max_values = []
        for col in transposed_arr:
            max_val = col[0]
            for val in col[1:]:
                max_val = smax(max_val, val)
            max_values.append(max_val)

    elif axis == 1:
        max_values = []
        for row in arr:
            max_val = row[0]
            for val in row[1:]:
                max_val = smax(max_val, val)
            max_values.append(max_val)

    else:
        raise ValueError("Invalid axis. Use 0 for rows or 1 for columns.")

    return max_values

def equal_lists(list1, list2):
    if len(list1) != len(list2):
        raise ValueError("Lists must be of the same length.")

    result = Array(len(list1), sint)

    for i in range(len(list1)):
        result[i] = list1[i] == list2[i]

    return result

def extract_columns(X_view, i, j):
    length = len(X_view)
    column_i = Array(length, sfix)
    column_j = Array(length, sfix)

    @for_range(length)
    def _(index):
        column_i[index] = X_view[index][i]
        column_j[index] = X_view[index][j]

    return column_i, column_j

def dot_product_matrix(x, y):
    dp = sfix(0)
    for i in range(len(x)):
        dp += dot_product(x[i], y[i])
    return dp

def dot_product(x, y):
    dp = x.same_shape().assign_all(0)
    for i in range(len(x)):
        if i>0:
            dp[i] = dp[i-1]+(x[i]*y[i])
        else:
            dp[i] = x[i]*y[i]
    return dp[len(x)-1]

# -------------------------------- EFC --------------------------------

def site_freq(X_view, psdcounts, max_bin):
    n_attr = len(X_view[1]) # total feature
    sitefreq = zeros_2d_by_shape(n_attr, max_bin)
    X_view_trans = X_view.transpose()

    @for_range(n_attr)
    def f(i):
        @for_range(max_bin)
        def h(aa):
            sitefreq[i][aa] = sum_of_equal_scalar(X_view_trans[i], aa)

    sitefreq = divide_2d_matrix_by_scalar(sitefreq, len(X_view))
    # TODO: maybe compute A / a * c = A* (c/a), no? So we can compute (c/a) (1-psdcounts/len(X_view)) locally and just 1 multiplication method is called, no matrix division needed
    sitefreq = multiply_2d_matrix_by_scalar(sitefreq, 1-psdcounts)
    addition = psdcounts / max_bin
    return add_scalar_to_2d_matrix(sitefreq, addition)

def pair_freq(X_view, sitefreq_view, psdcounts, max_bin):
    n_inst, n_attr = len(X_view), len(X_view[1])
    pairfreq = zeros_4d_by_shape(n_attr, max_bin, n_attr, max_bin)

    for i in range(n_attr):
        for j in range(n_attr):
            column_i, column_j = extract_columns(X_view, i, j)
            c = cantor(column_i, column_j)
            unique, aaIdx = unique_list(c, return_indices=True)

            @for_range(unique.length)
            def _(x):
                item = unique[x]
                comparison_results = equal_scalar(c, item)

                sum_result = 0

                for result in comparison_results:
                    sum_result += result

                pairfreq[i][X_view[aaIdx[x].reveal()][i].reveal()][j][X_view[aaIdx[x].reveal()][j].reveal()] = sum_result

    pairfreq = divide_4d_matrix_by_scalar(pairfreq, n_inst)
    pairfreq = multiply_4d_matrix_by_scalar(pairfreq, 1-psdcounts)
    pairfreq += (psdcounts / (max_bin ** 2))

    for i in range(n_attr):
        @for_range(max_bin)
        def _(x):
            @for_range(max_bin)
            def _(y):
                pairfreq[i][x][i][y] = (x == y).if_else(sitefreq_view[i][x], 0.0)


    return pairfreq

def coupling(pairfreq_view, sitefreq_view, psdcounts, max_bin):
    n_attr = len(sitefreq_view)
    corr_matrix = zeros_2d_by_shape(n_attr * (max_bin - 1), n_attr * (max_bin - 1))

    for i in range(n_attr):
        for j in range(n_attr):
            for ai in range(max_bin - 1):
                for aj in range(max_bin - 1):
                    corr_matrix[i * (max_bin - 1) + ai][j * (max_bin - 1) + aj] = (
                            pairfreq_view[i][ai][j][aj] - sitefreq_view[i][ai] * sitefreq_view[j][aj])

    #inv_corr = matrix_inverse(corr_matrix, 1000)

    inv_corr = Matrix(4, 4, sfix)

    inv_corr[0][0] = 9.814814
    inv_corr[0][1] = 6.111111
    inv_corr[0][2] = -1.111111
    inv_corr[0][3] = 0.481481

    inv_corr[1][0] = 6.111111
    inv_corr[1][1] = 8.333333
    inv_corr[1][2] = 0.666666
    inv_corr[1][3] = 2.111111

    inv_corr[2][0] = -1.111111
    inv_corr[2][1] = 0.666666
    inv_corr[2][2] = 5.333333
    inv_corr[2][3] = 2.888888

    inv_corr[3][0] = 0.481481
    inv_corr[3][1] = 2.111111
    inv_corr[3][2] = 2.888888
    inv_corr[3][3] = 9.148148


    neg_matrix = negative_matrix(inv_corr)
    exp_matrix = exponential_matrix(neg_matrix)

    result = zeros_2d_by_shape(n_attr * (max_bin - 1)+1, n_attr * (max_bin - 1))
    for i in range(n_attr * (max_bin - 1)):
        for j in range(n_attr * (max_bin - 1)):
            result[i][j] = exp_matrix[i][j]
    return result

def local_fields(coupling_view, pairfreq_view, sitefreq_view, psdcounts, max_bin):
    n_inst = len(sitefreq_view)
    fields = Array(n_inst * (max_bin - 1)+1, sfix)

    for i in range(n_inst):
        for ai in range(max_bin - 1):
            idx = i * (max_bin - 1) + ai
            fields[idx] = sitefreq_view[i][ai] / sitefreq_view[i][max_bin - 1]

            for j in range(n_inst):
                acc = 1
                for aj in range(max_bin - 1):
                    acc *= (coupling_view[idx][j * (max_bin - 1) + aj] ** sitefreq_view[j][aj])
                
                fields[idx] /= acc
                
    return fields


def compute_energy_new(X, coupling_matrix, local_fields, max_bin):
    n_inst, n_attr = len(X), len(X[0])
    energies = zeros_1d(n_inst)

    for i in range(n_inst):
        matrix_selector1 = zeros_1d_by_shape(len(local_fields))
        matrix_selector2 = zeros_2d_by_shape(len(coupling_matrix), len(coupling_matrix[0]))

        for j in range(n_attr):
            j_value = X[i][j]
            is_j_value = (j_value != (max_bin-1)).if_else(1, 0)

            for k in range(j, n_attr):
                k_value = (is_j_value == 0).if_else(max_bin-1, X[i][k])
                is_k_value = (k_value != (max_bin-1)).if_else(1,0)

                for l in range(len(coupling_matrix)):
                    for m in range(len(coupling_matrix[0])):
                        condition1 = (l==(j * (max_bin - 1) + j_value)).if_else(1,0)
                        condition2 = (m==(k * (max_bin - 1) + k_value)).if_else(1,0)
                        condition3 = (is_k_value == 1).if_else(1,0)
                        matrix_selector2[l][m] = ((condition1 + condition2 + condition3) == 3).if_else(1,matrix_selector2[l][m])

            for k in range(len(local_fields)):
                condition1 = (k == (j * (max_bin - 1) + j_value)).if_else(1,0)
                condition2 = (is_j_value == 1).if_else(1,0)
                matrix_selector1[k] = (condition1 + condition2==2).if_else(1, matrix_selector1[k])
        
        energies[i] -= dot_product_matrix(coupling_matrix, matrix_selector2)
        energies[i] -= dot_product(local_fields, matrix_selector1)
    
    print_ln("Energies: %s", energies.reveal())

    return energies

def compute_energy(X, coupling_matrix, local_fields, max_bin):
    n_inst, n_attr = len(X), len(X[0])
    energies = zeros_1d(n_inst)
    indexes1 = zeros_2d_by_shape(n_inst,n_attr)

    for i in range(n_inst):
        for j in range(n_attr):
            j_value = X[i][j]
            is_j_value = (j_value != (max_bin-1)).if_else(1, 0)
            for k in range(j, n_attr):
                k_value = (is_j_value == 0).if_else(max_bin-1, X[i][k])
                is_k_value = (k_value != (max_bin-1)).if_else(1, 0)
                idx_1 = (is_k_value + is_j_value == 2).if_else(j * (max_bin - 1) + j_value, len(coupling_matrix)-1)
                idx_2 = (is_k_value + is_j_value == 2).if_else(k * (max_bin - 1) + k_value, 0)
                energies[i] = energies[i] - coupling_matrix[idx_1.reveal()][idx_2.reveal()]
            indexes1[i][j] = (is_j_value==1).if_else(j * (max_bin - 1) + j_value, -1)
            #energies[i] = energies[i] - local_fields[idx.reveal()]

    matrix_selector1 = create_matrix_selector(local_fields, indexes1)

    for i in range(n_inst):
        energies[i] -= dot_product(local_fields, matrix_selector1[i])
        #subtraction2[i] += dot_product(local_fields, matrix_selector[i])

    print_ln("Energies old: %s", energies.reveal())
    return energies

def fit(X, pseudocounts, max_bin):
    sitefreq = site_freq(X, pseudocounts, max_bin)
    pairfreq = pair_freq(X,sitefreq, pseudocounts, max_bin)
    coupling_matrix = coupling(pairfreq, sitefreq, pseudocounts, max_bin)
    localfields = local_fields(coupling_matrix, pairfreq, sitefreq, pseudocounts, max_bin)
    coupling_matrix = log_2d(coupling_matrix)
    localfields = log_1d(localfields)

    cutoff = define_cutoff(X, 0.95, coupling_matrix, localfields, max_bin)
    return coupling_matrix, localfields, cutoff

def define_cutoff(X, cutoff_quantile, coupling_matrix, local_fields, max_bin):
    energies = compute_energy_new(X, coupling_matrix, local_fields, max_bin)
    energies.sort()
    return energies[int(len(energies) * cutoff_quantile)]

def predict(X, coupling_matrix, localfields, cutoff, max_bin):

    energies = [compute_energy_new(X, coupling_matrix, localfields, max_bin)]
    y_pred = Array(len(X), cint)

    y_energies = []

    for row in range(len(X)):
        y_energies.append([energies[i][row] for i in range(len(energies))])
        # Compute minimum energy in a row
        min_energy = sfix(1683.0)  # Initialize min_energy to positive infinity,
        for i in range(len(energies)):
            current_energy = energies[i][row]
            #current_energy = sfix(current_energy)
            min_energy = (current_energy < min_energy).if_else(current_energy, min_energy)

        result = (min_energy < cutoff).if_else(0,1) # See if min_energy is below cutoff (non malicious) or above (malicious)
        y_pred[row] = result.reveal()

    return y_pred

# -------------------------------- TEST --------------------------------

def test_min_along_axis():
    print_ln("Test min_along_axis")
    arr = sfix.Matrix(3, 3)

    # Assign each element of the matrix individually
    arr[0][0] = sfix(5)
    arr[0][1] = sfix(1)
    arr[0][2] = sfix(7)
    arr[1][0] = sfix(2)
    arr[1][1] = sfix(3)
    arr[1][2] = sfix(6)
    arr[2][0] = sfix(8)
    arr[2][1] = sfix(4)
    arr[2][2] = sfix(2)

    expected_results = {
        1: [sfix(1), sfix(2), sfix(2)],
        0: [sfix(2), sfix(1), sfix(2)]
    }

    for axis, expected in expected_results.items():
        result = min_along_axis(arr, axis)
        expected_sfix = [sfix(e) for e in expected]
        print_ln("Testing axis: %s", axis)
        for i in range(len(result)):
            opened_result = result[i].reveal()
            opened_expected = expected_sfix[i].reveal()
            print_ln("Expected %s and got %s", opened_expected, opened_result)

def test_max_along_axis():
    print_ln("Test max_along_axis")
    arr = Matrix(3, 3, sfix)

    # Assign each element of the matrix individually
    arr[0][0] = sfix(5)
    arr[0][1] = sfix(1)
    arr[0][2] = sfix(7)
    arr[1][0] = sfix(2)
    arr[1][1] = sfix(3)
    arr[1][2] = sfix(6)
    arr[2][0] = sfix(8)
    arr[2][1] = sfix(4)
    arr[2][2] = sfix(2)

    # Define expected results for each axis
    expected_results = {
        0: [sfix(8), sfix(4), sfix(7)],  # Max along columns
        1: [sfix(7), sfix(6), sfix(8)]   # Max along rows
    }

    for axis, expected in expected_results.items():
        result = max_along_axis(arr, axis)
        print_ln("Testing axis: %s", axis)
        for i in range(len(result)):
            # Reveal the values for comparison
            opened_result = result[i].reveal()
            opened_expected = expected[i].reveal()  # Directly use expected sfix values
            print_ln("Expected %s and got %s", opened_expected, opened_result)

def test_equal_lists():
    print_ln("Test equal lists")
    list1 = Array(5, sint)
    list2 = Array(5, sint)

    for i in range(5):
        list1[i] = sint(i)
        list2[i] = sint(i)

    list2[2] = sint(3)

    result = equal_lists(list1, list2)

    for i in range(len(result)):
        print_ln("Element %s equal: %s", i, result[i].reveal())

def test_pair_freq():
    max_bin = 10
    # Smaller dimensions for demonstration
    X_dim = (3, 3) # Example dimensions for X_view
    sitefreq_dim = (3, max_bin) # Example dimensions for sitefreq_view

    X_view = Array(X_dim[0] * X_dim[1], sint)
    sitefreq_view = Matrix(sitefreq_dim[0], sitefreq_dim[1], sfix)

    # Populating X_view with integers 1 to 9
    for i in range(X_dim[0]):
        for j in range(X_dim[1]):
            X_view[i * X_dim[1] + j] = sint(i * X_dim[1] + j + 1)

    # Populating sitefreq_view with floating-point values starting from 0.01
    for i in range(sitefreq_dim[0]):
        for j in range(sitefreq_dim[1]):
            sitefreq_view[i][j] = sfix(0.01 * (i * sitefreq_dim[1] + j + 1))

    result = pair_freq(X_view, sitefreq_view, cfix(0.5), max_bin)
    print_ln("%s", result.reveal())

def test_coupling():
    n_attr = 2
    max_bin = 3

    sitefreq_view = Matrix(n_attr, n_attr, sfix)
    for i in range(n_attr):
        for j in range(max_bin-1):
            sitefreq_view[i][j] = sfix(i + j + 1)  # Dummy values

    pairfreq_view = MultiArray([MAX_ARRAY_SIZE, MAX_ARRAY_SIZE, MAX_ARRAY_SIZE, MAX_ARRAY_SIZE], sfix)
    for i in range(MAX_ARRAY_SIZE):
        for ai in range(MAX_ARRAY_SIZE-1):
            for j in range(MAX_ARRAY_SIZE):
                for aj in range(MAX_ARRAY_SIZE-1):
                    pairfreq_view[i][ai][j][aj] = sfix((i + ai + 1) * (j + aj + 1))  # Dummy values

    psdcounts = None
    corr_matrix_result = coupling(pairfreq_view, sitefreq_view, psdcounts, max_bin)
    corr_matrix_result.print_reveal_nested()

def test_local_fields():
    n_inst = 2  # Example number of instances
    max_bin = 3  # Example number of bins

    # Initialize dummy inputs with MultiArray
    coupling_dim = [n_inst * (max_bin - 1), n_inst * (max_bin - 1)]
    coupling_view = MultiArray(coupling_dim, sfix)
    for i in range(coupling_dim[0]):
        for j in range(coupling_dim[1]):
            coupling_view[i][j] = sfix(1 + i + j)  # Example values

    sitefreq_dim = [n_inst, max_bin]
    sitefreq_view = MultiArray(sitefreq_dim, sfix)
    for i in range(n_inst):
        for ai in range(max_bin):
            sitefreq_view[i][ai] = sfix(1 + ai)  # Example values

    psdcounts = sfix(0.5)  # Example psdcounts value

    # Call the local_fields function
    fields = local_fields(coupling_view, None, sitefreq_view, psdcounts, max_bin)

    # Print the fields for verification
    print_ln("Fields:")
    for i in range(n_inst * (max_bin - 1)):
        print_ln("%s", fields[i].reveal())

def test_compute_energy():
    max_bin = 3
    X = Matrix(4, 2, sint)
    X[0][0] = 1
    X[0][1] = 0
    X[1][0] = 1
    X[1][1] = 2
    X[2][0] = 0
    X[2][1] = 0
    X[3][0] = 0
    X[3][1] = 2
    coupling_matrix = Matrix(5, 4, sfix)
    local_fields = Array(5, sfix)
    coupling_matrix[0][0] = -1.37894
    coupling_matrix[0][1] = 1.20692
    coupling_matrix[0][2] = -0.27507
    coupling_matrix[0][3] = 0.422714

    coupling_matrix[1][0] = 1.07326
    coupling_matrix[1][1] = -1.29245
    coupling_matrix[1][2] = -0.684616
    coupling_matrix[1][3] = 0.943817

    coupling_matrix[2][0] = -0.271118
    coupling_matrix[2][1] = -0.361786
    coupling_matrix[2][2] = -3.04189
    coupling_matrix[2][3] = 0.716873

    coupling_matrix[3][0] = 0.0263824
    coupling_matrix[3][1] = 0.500992
    coupling_matrix[3][2] = 1.02188
    coupling_matrix[3][3] = -3.95467

    # Assign values one by one to local_fields
    local_fields[0] = 1.03217
    local_fields[1] = 1.1356
    local_fields[2] = 1.41162
    local_fields[3] = -0.902969

    # Call the compute_energy function
    energies = compute_energy_new(X, coupling_matrix, local_fields, max_bin)
    energies.print_reveal_nested()


#----------------------------------- TESTING -----------------------------------
# --------- INPUT DATA ---------
X_train = Matrix(4, 2, sint)
X_train[0][0] = 0
X_train[0][1] = 0
X_train[1][0] = 1
X_train[1][1] = 2
X_train[2][0] = 1
X_train[2][1] = 0
X_train[3][0] = 1
X_train[3][1] = 2

y_train = Array(4, sint)
y_train[0] = 0
y_train[1] = 0
y_train[2] = 1
y_train[3] = 0


X_test = Matrix(4, 2, sint)
X_test[0][0] = 1
X_test[0][1] = 0
X_test[1][0] = 1
X_test[1][1] = 2
X_test[2][0] = 0
X_test[2][1] = 0
X_test[3][0] = 0
X_test[3][1] = 2

y_test = Array(4, sint)
y_test[0] = 1
y_test[1] = 1
y_test[2] = 0
y_test[3] = 1

max_bin = 3

# --------- TRAINING PHASE ---------
# Train the classifier
coupling_matrix, localfields, cutoff = fit(X_train, sfix(0.5), max_bin)
coupling_matrix.print_reveal_nested()
localfields.print_reveal_nested()
print_ln("%s cutoff orig", cutoff.reveal())

# Save the classifier info to file
cutoff_arr = Array(1, sfix)
cutoff_arr[0] = cutoff
cutoff_arr.write_to_file(position = 0)
#sfix.write_to_file(cutoff, position = 0)
coupling_matrix.write_to_file(position = 1)
localfields.write_to_file(position = (1+(len(coupling_matrix)*len(coupling_matrix[0]))))


# --------- INFERENCE PHASE ---------
# Read classifier's info from file
coupling_matrix = Matrix(5, 4, sfix)
localfields = Array(5, sfix)

cutoff_arr_presaved = Array(1, sfix)
cutoff_arr_presaved.read_from_file(0)
cutoff_presaved = cutoff_arr_presaved[0]
coupling_matrix_presaved = Matrix(len(coupling_matrix), len(coupling_matrix[0]), sfix)
coupling_matrix_presaved.read_from_file(1)
localfields_presaved = Array(len(localfields), sfix)
localfields_presaved.read_from_file(1+(len(coupling_matrix)*len(coupling_matrix[0])))

print_ln("%s cutoff presaved", cutoff_presaved.reveal())
print_ln("%s couplong presaved", coupling_matrix_presaved.reveal())
print_ln("%s localfields presaved", localfields_presaved.reveal())
y_pred_presaved = predict(X_test, coupling_matrix_presaved, localfields_presaved, cutoff_presaved, max_bin)
y_pred_presaved.print_reveal_nested()
precision, recall = calculate_metrics(y_test, y_pred_presaved)

print_ln("Precision pres: %s", precision.reveal())
print_ln("Recall pres: %s", recall.reveal())

